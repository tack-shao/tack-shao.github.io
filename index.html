<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Tack&#39;s coding vlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Tack&#39;s coding vlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Tack&#39;s coding vlog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tack&#39;s coding vlog">
  
    <link rel="alternate" href="/atom.xml" title="Tack&#39;s coding vlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Tack&#39;s coding vlog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-键鼠宏的思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/键鼠宏的思考/" class="article-date">
  <time datetime="2018-11-24T06:43:10.000Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/键鼠宏的思考/">键鼠宏的思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="键鼠宏的思考"><a href="#键鼠宏的思考" class="headerlink" title="键鼠宏的思考"></a>键鼠宏的思考</h2><hr>
<h3 id="键鼠宏的功能和使用场景就不再赘述，这里主要考虑办公驱动需要的宏实现方案。"><a href="#键鼠宏的功能和使用场景就不再赘述，这里主要考虑办公驱动需要的宏实现方案。" class="headerlink" title="键鼠宏的功能和使用场景就不再赘述，这里主要考虑办公驱动需要的宏实现方案。"></a>键鼠宏的功能和使用场景就不再赘述，这里主要考虑办公驱动需要的宏实现方案。</h3><p>办公驱动过滤方案目前使用的是原始输入和钩子配合获取输入消息，改键部分中使用到模拟键盘和模拟鼠标的api还有其他操作。<br>宏的实现主要分为两个部分，宏录制和宏播放。</p>
<hr>
<ul>
<li>宏录制<br>用户进入录制模式后，程序后台开始停止输入消息拦截和改键，只留监听用户输入的部分。所以录制也是重点，但是其实说白了就是录下用户特定时期<br>内输入的输入消息。游戏鼠标驱动的宏是我们公司主推的热点，所以宏的要求比较高（虽然宏播放的实现十分只简单，由于游戏鼠标的特性）目前也是<br>经过用户和市场的考量，所以也列入我的考量范围之内。具体实现方法就是在用户进入录制窗口之后，重载鼠标按下、松开消息和滚轮消息捕获键值。<br>这个简单方式确实符合目前的使用场景，但是虽然捕获了键值消息，事件有没有拦截我暂时还清楚，这个需要确认。</li>
</ul>
<hr>
<ul>
<li>宏播放<br>宏播放说白了就是执行用户之前录制的键鼠消息，可以通过模拟键盘和模拟鼠标api实现，简单。当然还要录制消息之间的时间间隔，所以会形成一个<br>宏消息队列的规范，这个我司内部有，json格式的，其实也是很简单的一些属性的封装而已。但是，这其中有个重点问题：宏播放中断<br>宏播放中断，就是可以随时中断某个正在播放的宏（宏的时长可能很长），简单来说，在一种场景中必须要这个功能。连续启动宏之后，最后一次启动开始<br>会执行完，之前的宏都会在下一次启动的时候停止。<br>也就是说，宏的播放可能需要参考一下视频或者音频播放的机制。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/键鼠宏的思考/" data-id="cjtzp9qxc0001ev8wwz6npdz2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-键盘过滤驱动解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/23/键盘过滤驱动解决方案/" class="article-date">
  <time datetime="2018-11-23T06:47:18.000Z" itemprop="datePublished">2018-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/23/键盘过滤驱动解决方案/">键盘过滤驱动解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="键盘过滤驱动解决方案"><a href="#键盘过滤驱动解决方案" class="headerlink" title="键盘过滤驱动解决方案"></a>键盘过滤驱动解决方案</h2><hr>
<ul>
<li><strong>需求</strong></li>
<li><strong>思路</strong></li>
<li><strong>整体方案</strong></li>
<li><strong>总结</strong> </li>
</ul>
<hr>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>上篇文章说到我开发完蓝牙鼠标驱动过滤之后，产品那边接下来理所当然的就会让我开始蓝牙键盘过滤了。键盘的过滤也是主要完成两部分，一是键盘设备的识别，二是键盘特殊键事件的拦截。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路大致与鼠标事件拦截和识别一致。  </p>
<ul>
<li><p>1、首先识别键盘hid句柄的handle，保存起来作为一个特征识别码。</p>
</li>
<li><p>2、使用win32 api中的getrawinputdata获取实时输入消息，解析消息知道，里面包含hid handle，看是否与我们需要的hid匹配，匹配则恭喜，不匹配就gg了。（悲剧的是雷柏的键盘gg了，by the way，罗技的是可以匹配hid的，他们具体怎么实现，我猜测是固件端的事情了）</p>
</li>
<li><p>3、通过设置全局键盘钩子，拦截键盘事件（这个好解决），拦截到事件之后，获取数据缓冲区的输入消息，解析handle是否为我们所需要的键盘，是这拦截事件并且发送信号给功能模块。不是则不拦截。</p>
</li>
</ul>
<h3 id="整体方案"><a href="#整体方案" class="headerlink" title="整体方案"></a>整体方案</h3><p>整体方案的实现，其实说白了就是封装一个拦截模块，用于识别我们的设备的事件并拦截下来，发送相应的信号给另一个模块。<br>这个拦截模块包括2.4g和蓝牙（仅支持4.0，原因很狗血，因为雷柏的设备在3.0的时候是不能识别硬件地址特征码的，罗技的可以！！）。<br>模块首先包括启动和停止：<br>程序在某个地方可以随机启动拦截模块，也可以随机关闭拦截模块。</p>
<pre><code>/**
 * @brief The RapooMouseHandler class
 * 封装蓝牙鼠标的相关通信
 * 封装hid相关的数据读取
 * PS:
 *  BLE通信之前都必须枚举设备、服务、特征、判断是否可以通信
 *  目前支持的操作
 *      1、切换设备changeDevice（实现切换蓝牙连接鼠标设备
 *
 * 2018 10 25 11:48
 * 同时封装了全局鼠标钩子
 *
 * 2018 11 20 16:03
 * 添加支持键盘，并且整理代码
 */
class RapooHandler : public QObject
{
    Q_OBJECT
public:
    RapooHandler(QObject* parent = 0);
    ~RapooHandler();

#ifdef USE_BLE_DLL
    /**
     * @brief changeDevice 切换设备使用的，但是目前先不使用
     * @param device
     * @return
     */
    int changeDevice(int device);
#endif
    /**
     * @brief getDoMouseEventTask 获取鼠标事件监听线程指针
     * @return
     */
    DoMouseEventTask* getDoMouseEventTask();
    /**
     * @brief getHidCtrl 获取HID对象指针
     * @return
     */
    HidCtrl* getHidCtrl();

    /*提供前端接口实现，检查设备连接状态*/
    Q_INVOKABLE QVariantMap checkHidDeviceConnected();

signals:
    /**
     * @brief sig_MouseEvent 过滤鼠标事件信号
     * @param key 键值宏 见value.h头文件
     * @param bIsUp 是否松开
     */
    void sig_KeyEvent(int key, int nIsUp);
    /**
     * @brief sig_HidDeviceConnected hid设备连接
     * @param int 1表示连接 0表示断开
     */
    void sig_HidDeviceConnected(int);
public slots:
    /**
     * @brief slot_changeFilterKey 用于接收修改过滤的键值
     * @param qsKeys
     */
    void slot_changeFilterKey(QStringList qsKeys);
    /**
     * @brief slot_recvMouseEvent 用于接受鼠标信号
     * @param key
     * @param nIsUp
     */
    void slot_recvMouseEvent(int key, int nIsUp);
    /**
     * @brief HidDeviceConnectionSlot HID设备连接槽函数
     * @param state true为连接 false为断开连接
     * @param qsDevicePath 设备路径
     */
    void HidDeviceConnectionSlot(bool state, QString qsDevicePath);
private:
    HidCtrl*                    m_pHidCtrl = NULL;          //HID控制器
    BthCtrl*                    m_pBthCtrl = NULL;          //蓝牙控制器
    UsbDriver*                  m_pUsbDriver = NULL;        //USB驱动
    HidDeviceHotSwapEvent*      m_pHidDevHSEvnt = NULL;     //HID设备热拔插事件
    DoMouseEventTask*           m_pDoMouseEventTask = NULL; //鼠标事件监听器
    bool                        m_bLoadedBLEDll = false;
    DeviceConnectStatus         m_connectStatus;
    QStringList                 m_qslFilterKeys;            //存放过滤的键值
#ifdef USE_BLE_DLL
    InitBLE_Interface m_initBLE = 0;
    DestroyBLE_Interface m_destroyBLE = 0;
    SendChangeDeviceMsg_Interface m_sendChangeDeviceMsg = 0;
    FindHidAddrWithNameCut_Interface m_findHidAddrWithNameCut = 0;
    GetRapooBleStatus_Interface m_getRapooBleStatus = 0;
#endif
private:
    void destroyUsbDriver();
    /**
     * @brief enumAndSetOurDevice 枚举HID，查看是否有符合我们的设备
     * @return map 返回设备连接状态
     */
    QVariantMap enumAndSetOurDevice();

    /**
     * @brief findRapooBthHidDeviceFromSystem 查找蓝牙设备
     * @param miceMap
     * @return 返回0表表示没找到，返回1表示只有鼠标 返回2表示只有键盘，返回3表示都有
     */
    int findRapooBthHidDeviceFromSystem(QMap&lt;wstring, DeviceStruct&gt;&amp; miceMap);

    /**
     * @brief findRapooUsbHidDeviceFromSystem 查找2.4g设备
     * @param miceMap
     * @return 返回0表表示没找到，返回1表示只有鼠标 返回2表示只有键盘，返回3表示都有
     */
    int findRapooUsbHidDeviceFromSystem(QMap&lt;wstring, DeviceStruct&gt;&amp; miceMap);

#ifdef USE_BLE_DLL
    /**
     * @brief loadDllAndFunction 加载DLL和读取接口
     * @param path
     */
    int loadDllAndInterface();
#endif
};
</code></pre><p>以上为拦截模块的封装，实现就不提供了（毕竟涉及商业）；<br>简单来说，该模块的启动和关闭，基本就是在构造函数和析构函数中实现了，其他模块只要使用指针操作就能随意使用此模块，比如：<br>我们在main文件中启动了该模块：</p>
<pre><code>RapooHandler rapooHandler;                      // 鼠标处理程序
//连接鼠标事件监听线程发出的信号和功能中心的槽
QObject::connect(&amp;rapooHandler, &amp;RapooHandler::sig_KeyEvent,
                 &amp;mouseFunctionSenter, &amp;MouseFunctionSenter::slot_MouseEvent);
</code></pre><p>使用信号槽连接了功能实现模块。<br>功能实现模块无关拦截，所以在这里就不一一赘述了。<br>当然要完全实现这个模块肯定还需很多复杂的操作。<br>下面在看看全局钩子的实现：</p>
<pre><code>/**
 * @brief The KeyboardHook class
 * 键盘钩子
 */
class KeyboardHook
{
public:
    KeyboardHook(HOOKPROC proc);
    ~KeyboardHook();
    /**
     * @brief getKeyboardHookHandle 获取键盘钩子句柄
     * @return
     */
    HHOOK getKeyboardHookHandle();

    /**
     * @brief initializeHook 初始化钩子，代码
     * @return  成功返回1 失败返回0
     */
    int initializeHook();


    /**
     * @brief removeHook 移除钩子
     * @return 成功返回1 失败返回0
     */
    int removeHook();

    bool isHookStart();

private:
    HWND m_hWnd = 0;
    HOOKPROC m_pHOOKPROC = 0;
    int m_nHookState = 0; //钩子状态，0位关闭，1位启动
    int m_nHookType = 0; //钩子类型，1表示代码 0表示dll注入
    static HHOOK s_hKeyboardHook; //键盘钩子句柄
};
</code></pre><p>通过initializeHook()和removeHook()在启动和关闭钩子，初始化的时候，传入钩子响应函数HOOKPROC proc作为参数。</p>
<p>实现了拦截模块的难点 <strong>在于如何平衡raw input和钩子事件哪个先触发</strong><br>在windows系统中，全局钩子拦截到的事件和raw input的输入消息的到达顺序是随机的，你不知道哪个先哪个后，然后我们要知道哪个事件属于我们的设备还要拦截它就是需要平衡这两者的顺序。<br><strong>解决方法</strong><br>维护一个raw input data队列，创建窗口响应函数读取raw input data，保存到队列中；在等待钩子钩到事件之后；先判断队列中有没有可用消息，有则进而判断消息的时间是否太长，我们决定100ms作为等待时间，超过这个时间的消息都算超时，抛弃；假如队列中没有消息，那么进而读取raw input data，判断data的handle是否为我们所需要，是则拦截，不是则不拦截。<br><strong>键盘拦截中需要注意</strong><br>键盘操作都包括按下 抬起两个动作，假如我们拦截了按下，但是漏掉了抬起，那么这个敲击事件就一直处于按下状态，相当于长按，这不是我们想要。如何解决这个问题呢。我们决定不需要键盘的按下消息，只需要抬起消息，（这和鼠标有点不大一样），一般人在拦截键盘改键功能的时候也不会有长按键盘的场景，就算有也可以通过其他方式实现。所以这个只需要拦截和识别抬起消息即可，难度大大降低，也大大增加稳定性。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>键盘拦截模块和鼠标拦截大同小异，细节方面有诸多问题要注意。基本上应用层拦截的可行性是ok的，但是前提条件是键盘设备能够被识别，即硬件特征地址码能够被识别和匹配。在这点上因为雷柏的键盘拦截功能键位是在特殊媒体键，然而雷柏键盘的媒体键识别的时候是没有handle的，亲测罗技的有，估计罗技的固件做了某种处理，所以此方案在雷柏键盘上并不能达到需求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/23/键盘过滤驱动解决方案/" data-id="cjtzp9qxt0004ev8wunj5e896" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-蓝牙鼠标驱动开发总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/01/蓝牙鼠标驱动开发总结/" class="article-date">
  <time datetime="2018-11-01T07:39:01.000Z" itemprop="datePublished">2018-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/01/蓝牙鼠标驱动开发总结/">蓝牙鼠标驱动开发总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="windows平台-蓝牙鼠标过滤"><a href="#windows平台-蓝牙鼠标过滤" class="headerlink" title="windows平台 蓝牙鼠标过滤"></a>windows平台 蓝牙鼠标过滤</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul>
<li>需求分析</li>
<li>思路</li>
<li>总结</li>
</ul>
<hr>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><em>来到雷柏的首次重要项目，内容是模仿罗技mxmaster鼠标驱动编写相关的鼠标驱动，我负责的内容是实现支持蓝牙的功能。需求简单分析就知道就是从电脑总线中识别出雷柏公司的蓝牙鼠标产品，并能过滤出该鼠标的鼠标事件，并且能够根据用户编辑的改键信息执行改键操作</em>  </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><em>实现该项目的重点主要分为两大模块</em></p>
<ul>
<li>实现从总线上识别我们的鼠标</li>
<li>过滤我们鼠标的事件。</li>
</ul>
<hr>
<h3 id="蓝牙识别"><a href="#蓝牙识别" class="headerlink" title="蓝牙识别"></a>蓝牙识别</h3><p>识别的实现主要使用蓝牙名，例如Rapoo，遍历蓝牙设备<br>基本操作就是使用SetupDiGetClassDevs (windows api)枚举蓝牙设备，注意参数GUID_DEVCLASS_BLUETOOTH 它在devguid.h头文件中，这里枚举到的蓝牙设备仅仅是已配对的设备，当然里面包括了已连接的设备，比如下图所以接下来我们还有操作。先看代码<br>代码如下:</p>
<pre><code>SP\_DEVINFO\_DATA did;  
DWORD i;  

//获取蓝牙相关设备集合  
HDEVINFO hDI = SetupDiGetClassDevs(&amp;GUID\_DEVCLASS\_BLUETOOTH, NULL, NULL,DIGCF_PRESENT);  
if (INVALID\_HANDLE\_VALUE == hDI)  
{  
     qDebug() &lt;&lt; u8&quot;INVALID\_HANDLE\_VALUE == hDI&quot;;  
     return 0;  
}  
did.cbSize = sizeof(SP\_DEVINFO\_DATA);  
for (i = 0; SetupDiEnumDeviceInfo(hDI, i, &amp;did); i++)  
{  
     //读取设备名称、硬件ID、实例路径  
     wstring name = getDeviceRegistryStringProperty(hDI, did, SPDRP_FRIENDLYNAME);  
     wstring hwId = getDeviceRegistryStringProperty(hDI, did, SPDRP_HARDWAREID);  
     wstring service = getDeviceRegistryStringProperty(hDI, did, SPDRP_SERVICE);  

     wstring deviceInstanceId;  
     DWORD bufferSize = 0;  
     while (!SetupDiGetDeviceInstanceId(  
             hDI,  
             &amp;did,  
             &amp;deviceInstanceId\[0\],  
             bufferSize,  
             &amp;bufferSize))  
     {  
         if (GetLastError() == ERROR\_INSUFFICIENT\_BUFFER)  
            deviceInstanceId.resize(bufferSize);  
         else  
         break;  
     }  

     if (name.size() &gt; 0)  
     {  
         //名称不为空的设备才是我们需要的  
         BthDeviceInfo *bthDeviceInfo = new BthDeviceInfo(rtrim\_null(name), rtrim\_null(hwId), rtrim_null(deviceInstanceId));  
         m\_bthEnumeratedDevices.push\_back(bthDeviceInfo);  
         qDebug() &lt;&lt; u8&quot;name :&quot; &lt;&lt; QString::fromStdWString(bthDeviceInfo-&gt;getName()) ;  
         qDebug() &lt;&lt; u8&quot;HW id:&quot; &lt;&lt; QString::fromStdWString(bthDeviceInfo-&gt;getHardwareId()) ;  
         qDebug() &lt;&lt; u8&quot;deviceInstanceId:&quot; &lt;&lt; QString::fromStdWString(bthDeviceInfo-&gt;getInstanceId()) ;  
         qDebug() &lt;&lt; u8&quot;service:&quot; &lt;&lt; QString::fromStdWString(service) ;  
     }  
 }
</code></pre><p>以上代码为枚举总线蓝牙设备，这里枚举到的蓝牙设备包括已配对的所有设备，所以可能出现同名的<br><img src="/2018/11/01/蓝牙鼠标驱动开发总结/1.png" alt><br>经过研究，知道蓝牙设备的地址为唯一的<br><img src="/2018/11/01/蓝牙鼠标驱动开发总结/2.png" alt><br>由上看出蓝牙4.0设备的实例路径前缀为BTHLE<br><img src="/2018/11/01/蓝牙鼠标驱动开发总结/3.png" alt>  </p>
<h3 id="HID识别"><a href="#HID识别" class="headerlink" title="HID识别"></a>HID识别</h3><p>我们上面的操作可以都到所有配对的蓝牙的实例路径了，然后通过名称特征可以过滤出我们需要的蓝牙设备的实例路径<br>通过研究，我们发现实例路径里面某些特征就是我们蓝牙设备的唯一特征值，比如<br>RAPOO BT4.0 MS的特征地址为ED8E0EA5B6A9，然我们查找HID设备分支我们可以看到<br><img src="/2018/11/01/蓝牙鼠标驱动开发总结/4.png" alt><br>其中符合蓝牙低能耗GATT的HID设备为蓝牙4.0的，至于GATT是什么，我这个项目目前没有使用到所以不做赘述，蓝牙3.0的那个就是‘蓝牙HID设备’了。<br>这里的HID设备就是我们鼠标发生数据的来源了，关于HID识别的，我现阶段使用的是根据windows api raw input来识别，可能跟直接在设备管理器看到的设备信息有些出入，但是一切以rawinput能读到的信息为准。<br>获取原始输入数据有一个关键点，第一获取原始输入设备列表，第二获取原始输入消息。<br>获取原始输入设备列表使用GetRawInputDeviceList函数，具体可以查询MSDN，这里轻fuck一下MSDN。<br>代码如下:  </p>
<pre><code>int WinManyMouseDriver::init()  
 {  

     RAWINPUTDEVICELIST *devlist = NULL;  
     UINT ct = 0;  
     UINT i;  

     s_nAvailableMiceNum = 0;  

     //获取原始输入设备数  
     GetRawInputDeviceList(NULL, &amp;ct, sizeof (RAWINPUTDEVICELIST));  
     if (ct == 0)  //无啊，啥都没  
        return 0;  

     //获取原始输入设备，注意：alloca函数牛逼，做到了在栈上申请动态内存，还能不用管释放  
     devlist = (PRAWINPUTDEVICELIST) alloca(sizeof (RAWINPUTDEVICELIST) * ct);  
     GetRawInputDeviceList(devlist, &amp;ct, sizeof (RAWINPUTDEVICELIST));  
     for (i = 0; i &lt; ct; i++)  
     {  
        s_nAvailableMiceNum += InitSingleMice(&amp;devlist\[i\]);//鼠标名字 句柄 鼠标数统计  
     }  

     return s_nAvailableMiceNum;  
}
</code></pre><p>至此，获取到原始输入设备列表了，里面包括了各种输入设备，所以要做一些处理，过滤得到鼠标设备。<br>InitSingleMice()函数中就实现了初始化鼠标设备的操作。<br>判断输入设备不是鼠标，跳过   </p>
<pre><code>if (dev-&gt;dwType != RIM_TYPEMOUSE)  
 return 0;  ///不是鼠标，可能是键盘和其他啥的东西
</code></pre><p>使用GetRawInputDeviceInfoA函数获取设备信息，详细请查看MSDN，再次轻喷。<br>获取到形如：  </p>
<pre><code>\\\?\\HID#VID\_24AE&amp;PID\_1813&amp;MI_01&amp;Col01#9&amp;31d8bf8b&amp;0&amp;0000#{378de44c-56ef-11d1-bc8c-00a0c91405dd}
</code></pre><p>的设备名，其中可以看到PID和VID，2.4g的鼠标是根据接收器的PID、VID识别的，此阶段的操作也适用于2.4g设备。但是经过研究发现目前通过此方法找不到蓝牙3.0 设备的地址特征。所以本文的蓝牙鼠标仅支持蓝牙4.0。支持的系统为win8 win10 但是2.4g的可以在win7下完美运行。  </p>
<h3 id="过滤设备输入事件"><a href="#过滤设备输入事件" class="headerlink" title="过滤设备输入事件"></a>过滤设备输入事件</h3><p>上面捋清了识别特定蓝牙鼠标的思路，接下来我就要想办法实现拦截特定鼠标的鼠标事件了。<br>经过调研，也是上述windows api中的函数GetRawInputData() 可以读取原始输入消息，当然了这里读到的也是电脑的全部设备的输入消息。所以我要做一些过滤的处理： </p>
<pre><code>if (raw-&gt;header.dwType != RIM_TYPEMOUSE)  
 return 0; //不是鼠标类型的输入数据  
</code></pre><p>接下来需要解析鼠标消息动作，因为我们只需要特殊的动作，比如点击和滑动滚轮。想鼠标移动这些我们就不需要了，起码这个项目里面不需要。废话不多说，直接看代码  </p>
<pre><code>USHORT WinManyMouseDriver::parseMouseKeyValueFromMouse(const RAWMOUSE *mouse)  
{  
     //判断左键  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_1\_DOWN) {  
        return MouseDriver\_KEY::MouseDriver\_L_DOWN;  
     }  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_1\_UP) {  
        return MouseDriver\_KEY::MouseDriver\_L_UP;  
     }  
     //判断右键  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_2\_DOWN) {  
        return MouseDriver\_KEY::MouseDriver\_R_DOWN;  
     }  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_2\_UP) {  
        return MouseDriver\_KEY::MouseDriver\_R_UP;  
     }  
     //判断中键  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_3\_DOWN) {  
        return MouseDriver\_KEY::MouseDriver\_M_DOWN;  
     }  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_3\_UP) {  
        return MouseDriver\_KEY::MouseDriver\_M_UP;  
     }  
     //判断前进键  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_5\_DOWN) {  
        return MouseDriver\_KEY::MouseDriver\_F_DOWN;  
     }  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_5\_UP) {  
        return MouseDriver\_KEY::MouseDriver\_F_UP;  
     }  
     //判断后退键  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_4\_DOWN) {  
        return MouseDriver\_KEY::MouseDriver\_B_DOWN;  
     }  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_BUTTON\_4\_UP) {  
         return MouseDriver\_KEY::MouseDriver\_B_UP;  
     }  

     //滚轮  
     if (mouse-&gt;usButtonFlags &amp; RI\_MOUSE\_WHEEL)  
     {  
         if ((short)mouse-&gt;usButtonData &gt; 0)  
            return MouseDriver\_KEY::MouseDriver\_WHEEL_UP;  
         else if ((short)mouse-&gt;usButtonData &lt; 0)  
            return MouseDriver\_KEY::MouseDriver\_WHEEL_DOWN;  
         } /\* if */  
         if (mouse-&gt;usButtonFlags &amp; 0x0800) /*侧滚轮，经调试得到*/  
         {  
             if ((short)mouse-&gt;usButtonData &gt; 0)  
             return MouseDriver\_KEY::MouseDriver\_H\_WHEEL\_UP;  
         else if ((short)mouse-&gt;usButtonData &lt; 0)  
            return MouseDriver\_KEY::MouseDriver\_H\_WHEEL\_DOWN;  
     }  
     return 0;  
}
</code></pre><h4 id="按键消息的成对匹配"><a href="#按键消息的成对匹配" class="headerlink" title="按键消息的成对匹配"></a>按键消息的成对匹配</h4><p>我们知道，鼠标的按键消息（左键、右键、中键等）是分为按键和松开的，按一次就会有两个消息被拦截。这样我们就会面临一个棘手的问题。系统在合成一次鼠标按键事件时是需要成对的按下和松开响应的。所以我们要保证系统能够捕获成对的按下和抬起消息，并且需要按固定的顺序。因为我们这里使用了钩子，按键事件是被拦截的，不被拦截的事件就会交给系统，加入某次按键消息只拦截了按下，没拦截松开，系统就会捕获到松开，这是不允许的，反之亦然。所以我们需要做一些操作。  </p>
<pre><code>int WinManyMouseDriver::FilterUnpairKey(int key, bool bIsUp)  
{  
     if (key &lt; MouseDriver\_L\_DOWN || key &gt; MouseDriver\_F\_UP) /*过滤滚轮*/  
     return 1;  

     if (bIsUp) /*松开键值*/  
     {  
         bool bFound = false;  
         for (int item : m_nKeyQueue) //遍历键值队列  
         {  
             if (item + 1 == key) /*发现匹配的按下键值*/  
             {  
             m_nKeyQueue.removeOne(item);  
             bFound = true;  
             break;  
             }  
         }  
         if (bFound) return 1;  
         else  
         {  
             return 0;  
         }  
     }  
     else  
     {  
         m\_nKeyQueue.push\_back(key);  
            return 1;  
     }  
}
</code></pre><p>上述代码可知，我们的解决方案就是，把按下的键值消息放入队列中，响应到松开消息时进行判断，如果找到匹配的按下消息，则拦截松开消息，找不到说明此次按键事件有问题，我们不拦截，抛弃。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，这个项目历时一个月，经历了各种坎坷和惊喜。。。。。反正最终结果是好的。问候一下MSDN，对英语不好的国人来说很痛苦，而且就算看懂英语（我看英文的），给的信息也太少了。相比其他的官方文档简直弱爆了。个人从来没有打算在windows平台开发windows api相关的开发，深深不喜欢他的模式。再说一下罗技的，他的鼠标高级很多，很多操作是可以直接跟鼠标通信的，他的改键也是使用模拟按键，所以在该鼠标在游戏方面可能会存在失效。过滤鼠标事件这凡方面最好的方式就是在驱动层过滤，WDK编程暂时不想涉及，但是也做一点调研，所以我可以知道的是罗技MxMaster的驱动程序不是使用驱动级过滤，很可能实现方式也和我一样的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/01/蓝牙鼠标驱动开发总结/" data-id="cjtzp9qxs0003ev8w677b63i9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-代理ip池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/02/代理ip池/" class="article-date">
  <time datetime="2018-08-02T10:02:19.000Z" itemprop="datePublished">2018-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/02/代理ip池/">代理ip池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="代理IP池开发与flask-api服务器搭建"><a href="#代理IP池开发与flask-api服务器搭建" class="headerlink" title="代理IP池开发与flask api服务器搭建"></a>代理IP池开发与flask api服务器搭建</h2><hr>
<h3 id="代理IP池"><a href="#代理IP池" class="headerlink" title="代理IP池"></a>代理IP池</h3><ul>
<li>为什么要开发代理IP池</li>
<li>如何开发</li>
<li>怎么使用</li>
</ul>
<hr>
<h5 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h5><p>首先，我们做爬虫的都知道，挂代理是十分重要的反反爬虫的手段之一，所以代理ip成为爬虫的基本武器库。代理IP怎么来呢？可以买，但是作为穷逼的一员是不可能为了爬点漫画和视频去买东西的，话说我干嘛不直接买漫画或者视频。。。。总之，国内有很多代理Ip的网站都会发布一些免费ip，公开的，免费的东西肯定没有优质的啦，基本都被cut掉的了。但是所谓沙里淘金，n多免费ip中总有一点可靠的，所以免费的东西白用白不用，爬之。<br>ip来源有了，但是我们并不知道爬回来的ips何时被cut，不可能等我们正式用的时候才发现不能用，这不就尴尬了吗。所以需要开一条守护着线程在后台定时监测ip是否可用，不可用的删掉，然后判断ip数低于某个数值时就去爬取新的ip回来，当然新ip都是要检测通过再入库的。</p>
<h5 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h5><p>HOW？？写一个代理ip池需要什么呢？首先肯定是要写个爬虫爬取免费ip网站的ip回来的嘛。免费ip网站有很多，而且网站样式都大同小异，所以我大胆的假设，它们可以使用一个通用的爬虫来爬取：<br>比如:<br><img src="/2018/08/02/代理ip池/1.jpg" alt></p>
<h6 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h6><p>简单看来，这种表格的样式很简单就能爬去，只不过每个网站的数据排列可能顺序不同，比如上图的这个ip排在第一，port排在第二。 所以，只要把类型的位置以一个dict作为一个参数：  </p>
<pre><code>ips = self.__get_by_url(url, {&quot;ip&quot;: 0, &quot;port&quot;: 1, &quot;address&quot;: 2, &quot;ip_type&quot;: 5})

def __get_by_url(self, url, dict):
    try:
        r = requests.get(url, headers=self.headers, verify=True).content
    except Exception as e:
        ERROR(str(e))
        return None

    ip_list = []
    selector = BeautifulSoup(r, &apos;lxml&apos;)
    trs = selector.select(&quot;tr&quot;)

    ip_list = []
    if len(trs) &lt; 2:
        return []
    for tr in trs:
        tds = tr.select(&apos;td&apos;)
        ip = Ip()
        for i in range(len(tds)):
            if i == dict[&quot;ip&quot;]:
                ip.ip = tds[i].get_text().strip()
            if i == dict[&quot;port&quot;]:
                ip.port = tds[i].get_text().strip()
            if i == dict[&quot;address&quot;]:
                ip.address = tds[i].get_text().strip()
            if i == dict[&quot;ip_type&quot;]:
                ip.ip_type = tds[i].get_text().strip()
        ip_list.append(ip)
    return ip_list
</code></pre><p>是不是很简单？</p>
<h6 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h6><p>ok。爬回数据之后，需要检测是否能用，检测同样简单，原理就是使用这个ip取访问一个网站，如果能行说明ip是ok的，否则反之。 </p>
<pre><code>def validate_ip(ip):
    # 验证ip是否可用
    proxies = {&quot;http&quot;: &quot;http://%s:%s&quot; % (ip.ip, ip.port)}
    headers = {
        &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;,
        &apos;Accept-Language&apos;: &apos;en-US,en;q=0.5&apos;,
        &apos;Connection&apos;: &apos;keep-alive&apos;,
        &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,
        &apos;User - Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&apos;,
    }
    res = False
    try:
        r = requests.get(url=&apos;http://www.ip138.com/&apos;, headers=headers,
                         timeout=5, proxies=proxies)
        if r.ok:
            res = True
    except Exception as e:
        pass
return res
</code></pre><p>这里使用的测试网址是<a href="http://www.ip138.com/，当然你可以随便改，改成http://www.baidu.com" target="_blank" rel="noopener">http://www.ip138.com/，当然你可以随便改，改成http://www.baidu.com</a> 也行，需要注意的是，一定要带<a href="http://www.头" target="_blank" rel="noopener">http://www.头</a> 写完整的一个地址，这不像平时我们使用浏览器会帮我们补全。<br>检测通过之后可以保存起来了。</p>
<h6 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h6><p>保存使用mysql，创建一个新数据库命名为ip。<br>ok了，接下来看python 使用peewee建立ORM操作数据库。<br>首先定义Ip model类:</p>
<pre><code>import datetime, json
from flask_peewee.db import Model, AutoField, CharField, DateTimeField

from . import db

class Ip(Model):
    id = AutoField(primary_key=True)
    ip = CharField(max_length=16, null=False, default=&quot;&quot;, unique=True)
    port = CharField(max_length=5, null=False, default=&quot;&quot;)
    address = CharField(max_length=30, default=&quot;&quot;)
    ip_type = CharField(max_length=8)
    create_time = DateTimeField(default=datetime.datetime.now)

    def __str__(self):
        r = {}
        for k in self.__data__.keys():
            try:
                r[k] = str(getattr(self, k))
            except:
                r[k] = json.dumps(getattr(self, k))
        return str(r)

    class Meta:
        database = db
        table_name = &quot;ip&quot;
</code></pre><p>在初始化IP池的时候，我们顺便初始化数据库，就可以顺便建表</p>
<pre><code>import time

from concurrent.futures import ThreadPoolExecutor
from multiprocessing import Process

from app.models import Ip
from app.spider.IpSpider import IpSpdier, validate_ip
from app.util.log import *


class IpPool(object):
    process = None

    def __init__(self, check_timeout=60*30, keep_num=150):
        &quot;&quot;&quot;
        初始化
        :param check_timeout: 定期检测的时长
        :param update_num: 需要更新的数量
        &quot;&quot;&quot;
        self.check_timeout = check_timeout
        self.keep_num = keep_num
        self.spider = IpSpdier()
        self.executor = ThreadPoolExecutor(max_workers=10)

        # 初始化数据库
        if not Ip.table_exists():
            Ip.create_table()

    def __del__(self):
        if self.process:
            # 析构函数
            self.process.terminate()
            self.process.join()
            INFO(&quot;IpPool子进程结束&quot;)

    def dowork(self):
        if not self.process:
            self.process = Process(target=self.__process_task)
            self.process.start()
        else:
            WARNING(&quot;子进程已启动&quot;)

    def __process_task(self):
        INFO(&quot;子进程启动&quot;)
        while True:
            self.check()
            INFO(&apos;完成检测, 等待%d秒 ...&apos; % self.check_timeout)
            time.sleep(self.check_timeout)

    def check(self):
        &quot;&quot;&quot;
        检测ip
        :return:
        &quot;&quot;&quot;
        INFO(&apos;检测ip池&apos;)
        datas = [ip for ip in Ip.select()]
        ip_num = len(datas)
        INFO(&apos;需要检测%d条记录&apos; % ip_num)
        ip_ids = []
        for data in self.executor.map(self.deal_single_ip, datas):
            if data != 0:
                ip_ids.append(data)
        print(&apos;ip_ids:&apos;, ip_ids)
        try:
            # 删除失败的ip
            nrows = Ip.delete().where(Ip.id &lt;&lt; ip_ids).execute()
        except Exception as e:
            print(e)

        blance = ip_num - nrows
        need = self.keep_num - blance
        INFO(&quot;完成检测, 当前ip数: %d&quot; % blance)
        if ip_num &lt; self.keep_num:
            INFO(&apos;ip池 余额不足 需要充值%d条&apos; % need)
            self.spider.crawl(need)

    def deal_single_ip(self, ip):
        res = False
        if not validate_ip(ip):
            # try:
            #     Ip.delete_by_id(ip.id)
            # except Exception as e:
            #     ERROR(e)
            return ip.id
        else:
            return 0
</code></pre><p>上面代码封装了IPPool的相关操作和属性，实现线程池定时检测和更新ip的操作。IpPool启动之后，会创建一个进程来完成定时检测并更新的操作。检测ip使用一个线程池来完成，运行10条线程完成ip池的检测。</p>
<h5 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h5><p>使用同样很简单，因为IpPool基本就是一个固定进程在维护一张数据库表，所以我们启动IpPool之后需要一直运行着。那么最好的做法就是把这玩意写在一个flask api的web后台，然后在后台启动它，我们通过api进行获取和删除的操作，最后部署到服务器上就完事了。使用的时候，利用api访问就可以了。</p>
<hr>
<h3 id="flask-api服务器搭建"><a href="#flask-api服务器搭建" class="headerlink" title="flask api服务器搭建"></a>flask api服务器搭建</h3><ul>
<li>flask web 开发</li>
<li>flask + nginx + supervisor + gunicorn + gevent 搭建服务器</li>
</ul>
<hr>
<h4 id="flask-web开发"><a href="#flask-web开发" class="headerlink" title="flask web开发"></a>flask web开发</h4><p><a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">flask 开发文档</a>自己看看，半天入门。<br>view的代码:   </p>
<pre><code>import json
from peewee import fn
from flask import request
from flask_json import as_json

from . import api
from .conf import *
from ..models import Ip
from ..util.schema import serializer_schema
from ..util.log import *
from ..util.PRPCrypt import PRPCrypt

# 加密类
prp = PRPCrypt(data_crypt_key)

@api.route(&apos;/ip&apos;, methods=[&apos;post&apos;])
def get():
    &quot;&quot;&quot;获取ip&quot;&quot;&quot;
    num = request.args.get(&apos;num&apos;, 1)
    raw_resp = {&apos;status&apos;: -1, &apos;message&apos;: &apos;FAIL&apos;, &apos;result&apos;: &apos;&apos;}

    if num == &apos;&apos;:
        num = &apos;1&apos;

    try:
        records = Ip.select().order_by(fn.Rand()).limit(int(num))
        raw_resp[&quot;status&quot;] = 0
        raw_resp[&quot;message&quot;] = &quot;SUCCESS&quot;
        raw_resp[&quot;result&quot;] = [str(record) for record in records]
    except Exception as e:
        raw_resp[&quot;status&quot;] = -1
        raw_resp[&quot;message&quot;] = &quot;FAIL&quot;
        raw_resp[&quot;result&quot;] = str(e)

    return json.dumps(raw_resp)


@api.route(&apos;/del&apos;, methods=[&apos;post&apos;])
def delete():
    &quot;&quot;&quot;删除一个ip&quot;&quot;&quot;
    ip = request.args.get(&apos;ip&apos;, &apos;&apos;)
    raw_resp = {&apos;status&apos;: -1, &apos;message&apos;: &apos;FAIL&apos;, &apos;result&apos;: &apos;&apos;}
    if ip == &apos;&apos;:
        print(&apos;参数为空&apos;)
        raw_resp[&quot;result&quot;] = &apos;参数为空&apos;
    else:
        ips = ip.split(&apos;,&apos;)
        try:
            nrows = Ip.delete().where(Ip.ip &lt;&lt; ips).execute()
            raw_resp[&quot;status&quot;] = 0
            raw_resp[&quot;message&quot;] = &quot;SUCCESS&quot;
            raw_resp[&quot;result&quot;] = &quot;deleted %d records.&quot; % nrows
        except Exception as e:
            raw_resp[&quot;status&quot;] = -1
            raw_resp[&quot;message&quot;] = &quot;FAIL&quot;
            raw_resp[&quot;result&quot;] = str(e)

    return json.dumps(raw_resp)
</code></pre><p>实现两个api:</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">args</th>
<th style="text-align:center">type</th>
<th style="text-align:center">example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ip</td>
<td style="text-align:center">num</td>
<td style="text-align:center">int</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">del</td>
<td style="text-align:center">ip</td>
<td style="text-align:center">str</td>
<td style="text-align:center">“19.23.45.6,34.45.75.4”</td>
</tr>
</tbody>
</table>
<h5 id="启动IP池"><a href="#启动IP池" class="headerlink" title="启动IP池"></a>启动IP池</h5><pre><code> # 启动爬虫线程
from app.spider import ip_pool_handle
ip_pool_handle.dowork()
</code></pre><h4 id="搭建nginx-spuervisor-gunicorn-gevent"><a href="#搭建nginx-spuervisor-gunicorn-gevent" class="headerlink" title="搭建nginx + spuervisor + gunicorn + gevent"></a>搭建nginx + spuervisor + gunicorn + gevent</h4><ul>
<li>nginx: 高性能 Web 服务器+负责反向代理</li>
<li>gunicorn: 高性能 WSGI 服务器</li>
<li>gevent: 把 Python 同步代码变成异步协程的库</li>
<li>supervisor: 监听 Linux 服务进程的工具</li>
</ul>
<p>额。。。。。是不是看起来很麻烦，其实也不麻烦，无非就是装几个程序然后写一些配置文件而已。</p>
<p>一件一件来。<br>nginx:   </p>
<pre><code>安装 yum install nginx -y
启动 nginx
重新加载 nginx -s reload
</code></pre><p>配置文件放在在/etc/nginx/conf.d/目录下。  </p>
<pre><code>server {
    listen      80; # 监听80端口

    root      /root/www/ippool;
    access_log /root/www/log/access_log;
    error_log  /root/www/log/error_log;

    server_name your_server; #写你的服务器ip或者域名

    # 动态请求转发到8181端口:
    # 这里只做动态请求转发
    location / {
        proxy_pass       http://0.0.0.0:8181;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
</code></pre><p>supervisor:</p>
<pre><code>安装 yum install supervisor -y
启动 supervisord
开启某个app spuervisorctl start your_app
关闭某个app spuervisorctl stop your_app
</code></pre><p>配置文件放在/etc/supervisord.d/中，默认的配置文件格式为<em>.ini，你也可以修改/etc/supervisord.conf文件中的include=”</em>.ini”为*.conf</p>
<pre><code>[program:ippool]

command     = /root/Envs/ippool/bin/gunicorn --bind 0.0.0.0:8181 --workers 3 --worker-class gevent manage:app
directory   = /root/www/ippool
user        = root
startsecs   = 3

autostart=true
autorestart=true
stopsignal=TERM

redirect_stderr         = true
stdout_logfile_maxbytes = 50MB
stdout_logfile_backups  = 10
stdout_logfile          = /root/www/log/ippool.log
</code></pre><p>关于gunicorn和gevent，都是在python环境中实现的，更简单，pip安装就完了，注意python2和python3的区分就行了。<br>基本上搭建就结束了，如何你嫌每次搞来搞去麻烦，那用python 的<a href="https://fabric-chs.readthedocs.io/zh_CN/chs/tutorial.html" target="_blank" rel="noopener">fabric</a>写个自动部署的脚本一件部署完事。有问题再去看log解决嘛。<br>最后测试一下:<br><img src="/2018/08/02/代理ip池/2.jpg" alt><br>最后附上地址<a href="https://github.com/tack-shao/IpPool" target="_blank" rel="noopener">https://github.com/tack-shao/IpPool</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/02/代理ip池/" data-id="cjtzp9qxr0002ev8w98737tl4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AStar寻路算法研究，运用于agv寻路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/11/AStar寻路算法研究，运用于agv寻路/" class="article-date">
  <time datetime="2017-10-11T06:25:25.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/11/AStar寻路算法研究，运用于agv寻路/">AStar寻路算法研究，运用于agv寻路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="A-算法研究，并运用于AGV寻路"><a href="#A-算法研究，并运用于AGV寻路" class="headerlink" title="A*算法研究，并运用于AGV寻路"></a>A*算法研究，并运用于AGV寻路</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前公司的AGV协同调度全权由服务器调度负责，还没有达到AGV单机计算路径和避让处理的阶段。<br>服务器中维护一个全局地图数据，把设备看作各个节点，<br>这里的路径规划的基础就是涉及静态图多节点的路径规划。这里使用的基础算法就是A<em>算法（前期阶段）。<br>所以以下内容仅关于A</em>算法展开讨论。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>在说寻路算法之前，先讨论一个地图的抽象和模拟。我们假设地图都是由不同的n<em>n的格子组成，<br>每个格子的可以是障碍物也可以是路径（可走和不可走）。<br>简单来说，A</em>寻路算法是启发式的算法，它始终维护一个open列表和一个close列表。<br>假设我们从S点寻找到E点的路径，从S点开始，它会把待处理的节点保存到open列表中表示待检测。如下图：</p>
<div align="center"><br><img width="150" height="150" src="/2017/10/11/AStar寻路算法研究，运用于agv寻路/1.jpg"></div>


<p>如上图，绿色方格为选中的起点，那么以它为中心的上下左右四角的方格都会存入待检测列表中，<br>即open列表中，但是图中只有右、左下、右下为可走的方格，所以只需要放入三个到open列表中，不可走的可以放入close列表中。</p>
<p>简单来说，每次都从open列表中找到最佳的节点，并把这个节点当作是路径的最新节点，直到一下几种情况出现为结束：</p>
<ul>
<li>open列表为空（没找到终点）</li>
<li>最新节点的x,y 等于终点的x,y（找到终点）</li>
</ul>
<h3 id="重点是如何在open列表中找到最佳节点"><a href="#重点是如何在open列表中找到最佳节点" class="headerlink" title="重点是如何在open列表中找到最佳节点"></a>重点是如何在open列表中找到最佳节点</h3><p>这里有一个公式:<strong>F = G + H</strong></p>
<p><strong>G表示起点到当前规划点的实际花费，H表示当前规划点到重点的预测花费</strong></p>
<p>我们需要找到f最小的节点，每次规划都选f最小的。<br>我们通过一开始的地图初始化是设定了方格的width为</p>
<div align="center"><img width="30%" height="30%" src="/2017/10/11/AStar寻路算法研究，运用于agv寻路/2.jpg"></div>

<p>所以，水平移动垂直移动的花费就是80，对角线移动即√2x80^2约等于113。<br>而起点到右边点的g为80，到左下和右下的g都是113，所以g在此就确定了。<br>接下来讨论h。</p>
<p>上文提到A*算法是启发式算法，简单说来就因为上面的公式需要计算h值–预测规划点到终点的话费。这里需要知道一个启发函数，计算h的值。<br>计算h的值，有很多种方式：</p>
<ul>
<li><p>曼哈顿距离<br>  不考虑对角线的距离，就仅考虑规划点到终点的水平距离与垂直距离，有公式:</p>
<pre><code>dx = abs(n.x - endpos.x)
dy = abs(n.y - endpos.y)
h(n) = width * (dx + dy)
</code></pre>  <div align="center"><img width="100%" height="100%" src="/2017/10/11/AStar寻路算法研究，运用于agv寻路/3.jpg"></div>

<p>  可见，在障碍物较少的地图中，规划的点较少，花费时间肯定较短。</p>
</li>
</ul>
<ul>
<li><p>对角线距离<br>  如果需要运行对角线移动，需要考虑对角线距离，注意这里的对角线距离D2=√2xD^2，D=width更为准确，有公式:</p>
<pre><code>dx = abs(n.x - endpos.x)
dy = abs(n.y - endpos.y)
h_diagonal(n) = min(dx, dy)
h_straight(n) = (dx + dy)
h(n) = D2 * h_diagonal(n) + D * (h_straight(n) - 2*h_diagonal(n)))
</code></pre>  <div align="center"><img width="100%" height="100%" src="/2017/10/11/AStar寻路算法研究，运用于agv寻路/4.jpg"></div>
</li>
<li><p>欧几里得距离<br>  直接上公式:</p>
<pre><code>dx = abs(n.x - endpos.x)
dy = abs(n.y - endpos.y)
h(n) = Dxsqrt((dx^2+dy^2))    
</code></pre>  <div align="center"><img width="100%" height="100%" src="/2017/10/11/AStar寻路算法研究，运用于agv寻路/5.jpg"></div>

<p>  由图可知，欧几里得算法需要规划的点数比较多，时间花费就比较长，但是从另一个意义上来说，最短路径更准确。</p>
</li>
<li><p>平方欧几里得距离<br>  简单来说就是欧几里得求平方</p>
<pre><code>dx = abs(n.x - endpos.x)
dy = abs(n.y - endpos.y)
h(n) = Dx((dx^2+dy^2))  
</code></pre>  <div align="center"><img width="100%" height="100%" src="/2017/10/11/AStar寻路算法研究，运用于agv寻路/6.jpg"></div>

<p>  欧几里得平方相比欧几里得少规划了很多节点，为什么呢？<br>  因为我们的公式F = G + H，F的大小由G和H决定，H平方之后，增大了和G的相差距离，减少G对F影响力，使算法更趋向于预测距离优先。这就退化了成BFS算法了，得不偿失，不要这样做。</p>
</li>
<li><p>Breaking ties<br>  简单来说，就是为什么会导致性能低，因为规划了更多的点，这些点中存在很多混淆的点，为什么会混淆，因为在open列表排序时，会存在f值相等的情况，最小值f点可能存在多个，所以会规划很多次与最佳路径可能关系不大的点，从而占用了大量的规划时间。<br>  解决这个问题最简单暴力的方式就是在比较函数中，如果f相等时，继续比较h。</p>
<pre><code>bool AStar::compare(Node *n1, Node *n2)
{
    if (n1-&gt;f == n2-&gt;f) /*f相同时判断h*/
    {
        return n1-&gt;h &lt; n2-&gt;h;
    }
    else
        return n1-&gt;f &lt; n2-&gt;f;
}
</code></pre><p>  当然，还有其他方式，前提是不能影响F的值。我们为启发函数添加一个附加值，附加值对于节点来说必须是确定的</p>
<blockquote>
<p>一种添加附加值的方式是稍微改变（译者注：原文为nudge）h的衡量单位。如果我们减少衡量单位（译者注：原文为scale it downwards），那么当我们朝着目标移动的时候f将逐渐增加。很不幸，这意味着A<em>倾向于扩展到靠近初始点的结点，而不是靠近目标的结点。我们可以增加衡量单位（译者注：原文为scale it downwards scale h upwards slightly）（甚至是0.1%），A</em>就会倾向于扩展到靠近目标的结点。</p>
<p>heuristic <em>= (1.0 + p)<br>选择因子p使得p &lt; 移动一步（step）的最小代价 / 期望的最长路径长度。假设你不希望你的路径超过1000步（step），你可以使p = 1 / 1000。添加这个附加值的结果是，A</em>比以前搜索的结点更少了。</p>
</blockquote>
<p>  这里，我们使用另一种方式，倾向于从初始点到目标点的连线（直线）：</p>
<pre><code>dx1 = cur.x - endpos.x
dy1 = cur.y - endpos.y
dx2 = startpos.x - endpos.x
dxy = startpos.y - endpos.y
cross = abs(dx1*dxy2 - dx2*dy1)
heuristic += cross*0.001
</code></pre></li>
</ul>
<h3 id="怎么设置最新路径点"><a href="#怎么设置最新路径点" class="headerlink" title="怎么设置最新路径点"></a>怎么设置最新路径点</h3><ul>
<li><p>假如规划点不存在于open列表中，计算FGH值之后设置“父节点”存入open列表。</p>
<ul>
<li><p>计算FGH值</p>
<p>  G = n.G + width</p>
<p>  H = 启发函数</p>
<p>  F = G + H</p>
</li>
<li><p>设置父节点，用于之后计算路径</p>
</li>
</ul>
</li>
<li><p>规划节点在open列表中</p>
<ul>
<li>判断经过规划点G是否更小（实际行驶距离是否更小）；如果更小说明规划点可走，设置“父节点”；没有更小，说明不必要走这个点。</li>
</ul>
</li>
</ul>
<p>如图：<br>    <div align="center"><img width="100%" height="100%" src="/2017/10/11/AStar寻路算法研究，运用于agv寻路/8.jpg"></div><br>红色：路径点 </p>
<p>绿色：规划过的点 </p>
<p>蓝色：计算的点，open列表中剩余的点 </p>
<p>ui说明: </p>
<p>row:    水平方向方格数 </p>
<p>column: 垂直方向方格数<br>width:  方格的边长 </p>
<p>障碍%:   表时出现障碍的概率 </p>
<p>time:   运行的时间 </p>
<p>启发函数: 启发函数 </p>
<p>附上代码: </p>
<p><a href="https://github.com/tack-shao/AStar_PathFindDemo" target="_blank" rel="noopener">https://github.com/tack-shao/AStar_PathFindDemo</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/11/AStar寻路算法研究，运用于agv寻路/" data-id="cjtzp9qx90000ev8wfi5gtylk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/24/键鼠宏的思考/">键鼠宏的思考</a>
          </li>
        
          <li>
            <a href="/2018/11/23/键盘过滤驱动解决方案/">键盘过滤驱动解决方案</a>
          </li>
        
          <li>
            <a href="/2018/11/01/蓝牙鼠标驱动开发总结/">蓝牙鼠标驱动开发总结</a>
          </li>
        
          <li>
            <a href="/2018/08/02/代理ip池/">代理ip池</a>
          </li>
        
          <li>
            <a href="/2017/10/11/AStar寻路算法研究，运用于agv寻路/">AStar寻路算法研究，运用于agv寻路</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Tack Shao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>